### 类加载详解

#### 类的生命周期

1. **加载（Loading）**
   - 将类的字节码文件从文件系统或其他介质中读取到内存中
2. **验证（Verification）**
   - 文件格式是否正确
3. **准备（Preparation）**
   - 为类的静态变量分配内存，并将这些变量初始化为默认值
4. **解析（Resolution）**
   - 将常量池中的符号引用转换为直接引用
5. **初始化（Initialization）**
   - 为静态变量赋予程序指定的初始值，并执行静态代码块
6. **使用**
7. **卸载**

#### 类加载器总结

1. **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2. **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3. **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

#### 双亲委派机制

![类加载器层次关系图](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png)

**优点：**

1. 保护JDK核心代码
2. 防止类被重复加载

#### 如何打破双亲委派机制

重写`ClassLoader`的`LoadClass()`方法

> 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。

### 垃圾回收机制

#### 堆的基本结构

1. 新生代
   - eden
   - s0
   - s1
2. 老年代
3. 永久代（jdk1.7之后是元空间）

#### GC区域

**部分收集 (Partial GC)：**

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

**整堆收集 (Full GC)：**收集整个 Java 堆和方法区。

#### 可被垃圾回收对象判断方法

1. **引用计数法**
2. **可达性分析算法**
   - 可被作为GCRoot的对象：
     - 虚拟机栈(栈帧中的局部变量表)中引用的对象
     - 本地方法栈(Native 方法)中引用的对象
     - 方法区中类静态属性引用的对象
     - 方法区中常量引用的对象
     - 所有被同步锁持有的对象
     - JNI（Java Native Interface）引用的对象

#### 引用类型

1. **强引用**
2. **软引用**
3. 弱引用
4. 虚引用

#### 垃圾收集算法

1. **标记-清除算法**
   - 首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象
2. **复制算法**
   - 将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。
3. **标记-整理算法**
   - 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
4. **分代收集算法**
   - 根据对象存活周期的不同将内存分为几块
   - 在新生代中，每次收集都会有大量对象死去，所以可以选择“复制”算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。