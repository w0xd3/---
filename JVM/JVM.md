### 内存区域

**程序计数器 (Program Counter Register)**

- 每个线程拥有一个独立的程序计数器，用于记录当前线程执行的字节码指令的地址。
- 如果线程正在执行本地方法，则计数器值为空。
- 程序计数器用于帮助线程在执行Java字节码时进行指令跳转和分支。

**Java虚拟机栈 (Java Virtual Machine Stack)**

- JVM栈是线程私有的，生命周期与线程相同。
- 每个方法在执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、方法出口等信息。
- JVM栈的作用是支持方法的调用和执行，Java中的方法调用和返回都通过栈进行管理。
- 当栈深度过深或栈内存不足时，会抛出`StackOverflowError`或`OutOfMemoryError`。

**本地方法栈 (Native Method Stack)**

- 用于执行本地方法（Native Method）时的数据存储。
- 本地方法是由其他编程语言（如C或C++）实现的代码，这些代码通过JNI调用。
- 类似于JVM栈，本地方法栈也会因为内存不足抛出异常。

**堆 (Heap)**

- 堆是线程共享的内存区域，用于存储Java对象和数组。
- 堆在JVM启动时创建，生命周期与JVM相同。
- 所有对象实例和数组都在堆中分配，是Java垃圾回收机制（GC）管理的主要区域。
- 堆可以细分为新生代（Young Generation）和老年代（Old Generation），其中新生代又包括Eden区和Survivor区，用于存储不同生命周期的对象。

**方法区 (Method Area)**

- 方法区是线程共享的内存区域，用于存储类信息、常量、静态变量和JIT（Just-In-Time）编译后的代码。
- 方法区是“逻辑上”堆的一部分，有时也称为“非堆”。
- 在HotSpot虚拟机中，方法区对应了“永久代”或“元空间”（JDK 8后为元空间）。
- 方法区会因为内存不足抛出`OutOfMemoryError`异常。

**运行时常量池 (Runtime Constant Pool)**

- 运行时常量池是方法区的一部分，用于存储编译期间生成的各种字面量（Literal）和符号引用（Symbolic Reference）。
- 常量池在类加载后被载入方法区中，可以在运行时动态添加新的常量。
- 运行时常量池的内存也受到限制，当常量池内存不足时会抛出`OutOfMemoryError`异常。

**直接内存 (Direct Memory)**

- 直接内存并不是JVM运行时数据区的一部分，但在JVM外部也可能被Java程序使用，如NIO（New I/O）中的`ByteBuffer.allocateDirect`方法分配的内存。
- 直接内存分配由操作系统管理，可以显著提升I/O操作的性能。
- 直接内存大小可以通过JVM参数`-XX:MaxDirectMemorySize`配置，默认与堆内存大小相同。

### 类加载详解

#### 类的生命周期

1. **加载（Loading）**
   - 将类的字节码文件从文件系统或其他介质中读取到内存中
2. **验证（Verification）**
   - 文件格式是否正确
3. **准备（Preparation）**
   - 为类的静态变量分配内存，并将这些变量初始化为默认值
4. **解析（Resolution）**
   - 将常量池中的符号引用转换为直接引用
5. **初始化（Initialization）**
   - 为静态变量赋予程序指定的初始值，并执行静态代码块
6. **使用**
7. **卸载**

#### 类加载器总结

1. **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2. **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3. **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

#### 双亲委派机制

![类加载器层次关系图](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png)

**优点：**

1. 保护JDK核心代码
2. 防止类被重复加载

#### 如何打破双亲委派机制

重写`ClassLoader`的`LoadClass()`方法

> 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。

### 垃圾回收机制

#### 堆的基本结构

1. 新生代
   - eden
   - s0
   - s1
2. 老年代
3. 永久代（jdk1.7之后是元空间）

#### GC区域

**部分收集 (Partial GC)：**

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

**整堆收集 (Full GC)：**收集整个 Java 堆和方法区。

#### 可被垃圾回收对象判断方法

1. **引用计数法**
2. **可达性分析算法**
   - 可被作为GCRoot的对象：
     - 虚拟机栈(栈帧中的局部变量表)中引用的对象
     - 本地方法栈(Native 方法)中引用的对象
     - 方法区中类静态属性引用的对象
     - 方法区中常量引用的对象
     - 所有被同步锁持有的对象
     - JNI（Java Native Interface）引用的对象

#### 引用类型

1. **强引用**
2. **软引用**
3. 弱引用
4. 虚引用

#### 垃圾收集算法

1. **标记-清除算法**
   - 首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象
2. **复制算法**
   - 将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。
3. **标记-整理算法**
   - 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
4. **分代收集算法**
   - 根据对象存活周期的不同将内存分为几块
   - 在新生代中，每次收集都会有大量对象死去，所以可以选择“复制”算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。