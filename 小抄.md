### 自我介绍引导

1. 个人情况（姓名，年级，院校）
2. 实习经历（时间、职责、工作内容）
   1. 拓竹
      - 介绍一下公司，3D打印机。部门有两个方向，打印机硬件测试，模型平台测试（偏软件）。
      - 50%功能测试，30%接口测试，20%压力测试。还有做一些性能测试的工作。
   2. 村民贷，校企合作项目
      - 开发新需求；对旧接口进行调整；nacos热配置
3. 项目
   1. taskzen
      - 时间管理系统
        - 登录注册
        - todolist
        - 任务时间表
        - 时间洞察
        - AIGC报告
4. 技能和专长
   1. java，对JVM和JUC有一定了解
   2. 自动化测试工具：自动化测试框架（pytest、selenium）、压力测试工具（jmeter）、接口测试工具（insomnia、postman）。以及手动测试方法论
   3. linux指令
   4. mysql的存储引擎、索引、锁
   5. 对spring有一点了解

#### 反问

1. 部门的职责、方向、人数、结构
2. 薪资结构

### 死锁

多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。

![image-20241018225901458](C:\Users\Wancy\AppData\Roaming\Typora\typora-user-images\image-20241018225901458.png)

#### 解决死锁的方法

解决死锁的方法可以从多个角度去分析，一般的情况下，有**预防，避免，检测和解除四种**。

- **预防** 是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
  1. 静态分配策略
  2. 层次分配策略（破坏循环等待链）
- **避免**则是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**
  - 银行家算法（分配前判断安不安全）
- **检测**是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除** 是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**。
  1. 立即结束所有进程
  2. 撤销涉及死锁的进程
  3. 抢占资源

### TCP和UDP的区别

1. 连接方式
2. 可靠性
3. 速度
4. TCP有流量控制和拥塞控制
5. 应用场景

![image-20241019092613887](C:\Users\Wancy\AppData\Roaming\Typora\typora-user-images\image-20241019092613887.png)

### DNS

#### 层级结构

自顶向下：

1. 根DNS服务器
2. 顶级域DNS服务器（TLD Top-Level-Domain）
3. 权威DNS服务器
4. 本地DNS服务器

#### 工作流程

- 递归
- 迭代

![img](https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process.png)

### Mysql

#### InnoDb和MyISAM区别

1. 事务
2. 锁
3. 外键
4. 数据存储和检索
5. 崩溃恢复

#### 索引类别

1. 按数据结构
   - **B-Tree 索引**：适用于等值和范围查询，使用最广泛。
   - **哈希索引**：只支持等值查询，速度快，不支持范围查询。
   - **R-Tree 索引**：用于多维空间数据查询，适合地理信息。
   - **位图索引**：适合重复值多的字段，效率高。
2. 按底层存储
   - **聚簇索引**：数据和索引存储在一起，查询效率高，但插入慢。
   - **非聚簇索引**：索引存储指针，支持多索引，但查询时可能回表。
3. 按应用维度
   - **主键索引**：唯一且不允许为空，自动生成聚簇索引。
   - **唯一索引**：保证列唯一性，提升查询速度。
   - **普通索引**：提升查询性能，无唯一性要求。
   - **全文索引**：加速大文本字段的内容搜索。
   - **组合索引**：多个字段联合索引，遵循最左前缀。
   - **覆盖索引**：查询所需字段都在索引中，无需回表。

#### 什么时候适合用索引

1. 列中属性不为null
2. 频繁查询字段
3. 条件查询字段
4. 排序字段
5. 连接字段

#### 索引失效

1. 使用组合索引，但查询条件未遵守最左匹配原则
2. 在索引列上进行计算、函数、类型转换等操作
3. 以%开头的Like查询
4. 查询条件中使用OR，且OR的前后条件有一个列没有索引
5. IN的取值范围过大，走全表扫描

### cookie、session、token区别

#### 工作原理

cookie的工作原理是将用户信息保存到浏览器的域中，每次发起请求时都携带这些信息。缺点是不安全。

session的工作原理是在第一次登录鉴权时，服务器创建一个会话，存储用户的信息，然后将sessionId返回给客户端（浏览器），每次请求时携带sessionId。优点是安全；缺点是占用服务器资源，并且存在多台服务器时无法使用。

token比上述两种更为常用，量级小且安全，常见的实现是使用JWT。在登陆成功后服务器返回一个jwt token给客户端，客户端后续请求时将这个token放到请求头的Authorization中。

### 进程和线程

进程是操作系统资源分配的最小单位，线程是程序执行的最小单位。

#### 区别

1. 资源开销
2. 安全性
3. 通信方式

#### 应用场景

1. 线程
   - 频繁创建销毁
   - CPU密集型
2. 进程
   - 对安全和稳定要求高。比如，浏览器使用独立进程处理不同标签页，以隔离崩溃影响。

### 调度算法

![image-20241018231900955](C:\Users\Wancy\AppData\Roaming\Typora\typora-user-images\image-20241018231900955.png)

### B树和B+树区别

- B+树非叶子节点不存储数据，相当于索引。叶子节点才存储数据
- B+树同层节点链表

## 开放性问题

### 浏览器白屏

### 从客户端排查

#### 可能的原因

1. javascript
2. 资源加载失败
3. API（HTTP状态码）
4. 网络问题
5. 代理问题
6. 插件
7. 浏览器缓存

#### 解决方案

- 使用浏览器开发者工具中的 **Console（控制台）**、**Network（网络）** 和 **Elements（元素）** 标签来检查页面加载过程中是否有错误、资源加载失败或数据问题。
- 根据具体的错误信息，检查 JavaScript 错误、网络请求失败或样式加载问题等。
- 清除缓存、更新浏览器、禁用插件等也是解决白屏问题的有效方法。

### 从服务器排查

- 查看服务器日志，分析是否有错误或异常。
- 检查 API 请求和响应，确认数据是否正常返回。
- 验证数据库和第三方服务是否工作正常。
- 排查反向代理、缓存、会话等配置是否正确。

### Pytest和JUnit的区别

junit大多是开发拿来自测的

我觉得功能上没什么区别，测试框架的顶层设计都是差不多的。比如说pytest支持参数化和异常测试，junit也支持。

区别更多在于生态和语言本身

1. python在自动化测试方面的生态比java好。天然就能跟request和selenium集成，java如果要发请求一般是使用apache的httpclient这个包。
2. python是脚本语言，也就是说在执行pytest指令时可以动态指定很多东西（比如说仅执行包含某个标签的用例）。而且python更倾向于使用函数，java更多是用类的设计。java代码冗余过多，作为测试人员我在乎的是用最少的代码解决问题，不关心细节。

我个人比较喜欢pytest的夹具和参数化测试这两个功能。

### 什么时候适合自动化

#### 自动化的应用场景

1. 稳定性高的场景
2. 回归测试时
3. 压力测试与负载测试
4. 数据驱动测试

#### 手动测试应用场景

1. 探索性测试
2. 用户体验
3. 快速迭代
4. 难以自动化（音频、视频、图像）

### Spring

待办：

个人项目补充一点内容

快速浏览spring的ioc、aop、事务

看计网

### 村民贷

#### redis缓存

1. 贷款客户数据缓存
2. 高风险客户预警信息缓存

#### mysql索引案例

见python文件

**输出：**

```
不使用索引的查询时间: 0.0753 秒
使用单列索引的查询时间: 0.0478 秒
使用覆盖索引的查询时间: 0.0214 秒
```

覆盖索引完胜，不用回表优势很大

### 个人项目亮点

#### 数据分析功能

#### `JWT` + 请求拦截 + 跨域问题

**`JWT`**

`JWT `是一个字符串，包含三部分：

1. **Header**（头部）
2. **Payload**（负载）
3. **Signature**（签名）

**请求拦截**

利用spring提供的`HandlerInterceptor`，配置拦截路径，指定拦截逻辑

**跨域**

1. 前端配置代理
2. 后端允许端口访问（`WebMvcConfigurer `）

# `Mysql`笔记

https://javaguide.cn/database/mysql/

### sql语句的执行顺序

![image-20240820114027032](https://cdn.xiaolincoding.com//picgo/image-20240820114027032.png)

#### sql语句的执行过程

![img](https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png)

**连接器：** 身份认证和权限相关(登录 MySQL 的时候)。

**查询缓存：** 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。

**分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。

**优化器：** 按照 MySQL 认为最优的方案去执行。

**执行器：** 执行语句，然后从存储引擎返回数据。 

## 存储引擎

### MYISAM和InnoDB实现上的区别

**事务支持**

- **MyISAM**：不支持事务，也没有回滚功能。一旦执行操作无法撤销。
- **InnoDB**：支持事务（ACID特性），可以使用 `COMMIT` 和 `ROLLBACK`，在出现错误时可以回滚事务，保证数据一致性。

**锁机制**

- **MyISAM**：使用表级锁，执行查询或写入操作时会锁定整个表，导致并发性能较差。
- **InnoDB**：使用行级锁，允许高并发读写操作，写入操作仅锁定特定行，因此并发性能更好。

**外键支持**

- **MyISAM**：不支持外键约束，因此无法直接在表间建立关系。
- **InnoDB**：支持外键，可以实现表之间的数据完整性和约束。

**数据恢复**

- **MyISAM**：在系统崩溃后，可能会造成数据丢失或损坏，恢复较困难。只支持简单的修复工具 `REPAIR TABLE`。
- **InnoDB**：崩溃恢复机制更完善，支持崩溃恢复（通过重做日志和回滚日志），可以最大程度上减少数据丢失。

**存储结构**

- **MyISAM**：使用表级存储结构，数据和索引分别存储在不同的文件中。表比较大时，性能可能下降。
- **InnoDB**：使用聚簇索引存储，数据与索引一起存储在同一个文件中，索引和数据一起优化存取效率。

**MVCC**

**索引实现**

- **MyISAM**：叶子节点存储的是页数据的地址。
- **InnoDB**：叶子节点存储的是主键的聚簇索引，即在数据本身建索引。

## 存储数据结构

### B树



### B+树



### B/B+树区别





## 索引

### `Mysql `EXPLAIN 详解

各个字段的含义如下：

| **列名**      | **含义**                                     |
| ------------- | -------------------------------------------- |
| id            | SELECT 查询的序列标识符                      |
| select_type   | SELECT 关键字对应的查询类型                  |
| table         | 用到的表名                                   |
| partitions    | 匹配的分区，对于未分区的表，值为 NULL        |
| **type**      | 表的访问方法                                 |
| possible_keys | 可能用到的索引                               |
| **key**       | 实际用到的索引                               |
| key_len       | 所选索引的长度                               |
| ref           | 当使用索引等值查询时，与索引作比较的列或常量 |
| **rows**      | 预计要读取的行数                             |
| filtered      | 按表条件过滤后，留存的记录数的百分比         |
| **Extra**     | 附加信息                                     |

#### **type**

- type列表示连接类型，是性能优化的关键字段之一，常见的连接类型按效率由高到低排列如下：
  - `system`: 表中只有一行（这是一个特殊的 `const` 类型），速度非常快。
  - `const`: 表示表只有一个匹配的行，通过索引或者主键查找，这种类型是性能最优的。
  - `eq_ref`: 对于联合查询，表示每次从表中读取一行，通常出现在多表连接中，基于主键或唯一索引的关联。
  - `ref`: 非唯一索引扫描，会返回匹配某个值的所有行。
  - `range`: 通过索引查找一个范围的行。
  - `index`: 扫描整个索引（比全表扫描稍好），不使用数据文件。
  - `ALL`: 全表扫描，效率最低。

#### **extra**

- extra列显示关于查询的额外信息，常见的值有：
  - `Using where`: `MySQL` 会使用 `WHERE` 子句来过滤行。
  - `Using index`: 表示只使用索引进行查找，无需额外读取数据文件，性能较高。
  - `Using temporary`: `MySQL` 需要使用临时表来存储中间结果，通常发生在 `GROUP BY`、`ORDER BY` 操作中，可能需要优化。
  - `Using filesort`: `MySQL` 使用文件排序，通常出现在 `ORDER BY` 子句，表示没有使用索引进行排序，可能影响性能。
  - `Using join buffer`: 使用了连接缓冲区，意味着连接条件可能不够优化。

### 索引的类型

1. 按数据结构
   - **B-Tree 索引**：适用于等值和范围查询，使用最广泛。
   - **哈希索引**：只支持等值查询，速度快，不支持范围查询。
   - **R-Tree 索引**：用于多维空间数据查询，适合地理信息。
   - **位图索引**：适合重复值多的字段，效率高。
2. 按底层存储
   - **聚簇索引**：数据和索引存储在一起，查询效率高，但插入慢。
   - **非聚簇索引**：索引存储指针，支持多索引，但查询时可能回表。
3. 按应用维度
   - **主键索引**：唯一且不允许为空，自动生成聚簇索引。
   - **唯一索引**：保证列唯一性，提升查询速度。
   - **普通索引**：提升查询性能，无唯一性要求。
   - **全文索引**：加速大文本字段的内容搜索。
   - **组合索引**：多个字段联合索引，遵循最左前缀。
   - **覆盖索引**：查询所需字段都在索引中，无需回表。

### 聚簇索引和非聚簇索引的优缺点、区别

#### **聚簇索引 (Clustered Index)**

**概念：**

- 在聚簇索引中，表中的数据行按照索引列的顺序进行物理存储。
- 每个表只能有一个聚簇索引，因为数据行的物理顺序只能有一种。
- 在 MySQL 的 InnoDB 引擎中，主键默认是聚簇索引，如果没有指定主键，MySQL 会选择一个唯一的非空列作为聚簇索引。

优点：

- **查询效率高**：当查询涉及聚簇索引列时，由于数据和索引在同一结构中，查询时不需要再次查找数据，查询速度更快，尤其是在范围查询时（例如 `BETWEEN`）。
- **顺序访问快**：聚簇索引将数据按索引列的顺序存储，适合顺序读取或范围查询。

缺点：

- **插入和更新效率低**：由于数据需要按索引列排序存储，插入新的数据或更新现有数据可能需要对其他数据进行重排，导致效率下降。
- **占用更多空间**：当聚簇索引的列比较大时，重新排序和维护索引开销较高。
- **数据移动**：如果插入的数据不能按顺序放入现有位置，可能需要将数据移动到其他位置，这会导致更多的 IO 操作。

场景：

- 适用于多范围查询、顺序查询以及查询返回多行的场景，例如时间戳、范围查询。

#### 非聚簇索引 (Non-clustered Index)

**概念：**

- 非聚簇索引中的索引顺序与表中数据的物理存储顺序没有关系。
- 在非聚簇索引中，索引结构包含指向数据行的指针（通常是指向聚簇索引或直接指向数据），不会改变数据的物理存储顺序。
- 一张表可以有多个非聚簇索引。

优点：

- **插入和更新操作快**：数据物理存储顺序与索引顺序无关，插入新数据时不需要对整个表进行重排，只需要更新索引即可，减少了数据移动的开销。
- **多重索引**：非聚簇索引支持在同一个表中创建多个索引，可以在不同列上建立索引，优化特定列的查询性能。

缺点：

- **查询效率较低**：当查询时，先需要通过索引查找到数据位置，然后再通过位置找到实际数据（称为“回表”操作）。特别是在范围查询时，由于指针跳转，效率不如聚簇索引。
- **占用更多空间**：非聚簇索引需要额外的空间存储指向数据行的指针，所以每个非聚簇索引都会增加额外的存储成本。

场景：

- 适用于精确查询，特别是在查询特定列的场景下，如通过唯一标识符查找记录。

------

**区别总结：**

| 对比维度     | 聚簇索引                                   | 非聚簇索引                               |
| ------------ | ------------------------------------------ | ---------------------------------------- |
| **数据存储** | 数据和索引一起存储                         | 索引和数据分开存储                       |
| **查询速度** | 查询范围数据时速度快                       | 查询速度相对较慢，需要“回表”操作         |
| **插入速度** | 插入或更新数据时速度较慢，可能需要重排数据 | 插入或更新速度较快                       |
| **索引数量** | 每个表只能有一个聚簇索引                   | 每个表可以有多个非聚簇索引               |
| **适用场景** | 顺序查询、大数据集的范围查询               | 精确查找特定列，特别是在联合查询中效果好 |

### 最左匹配原则

最左匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。

```sql
# 可以命中索引
SELECT * FROM student WHERE name = 'Anne Henry';
EXPLAIN SELECT * FROM student WHERE name = 'Anne Henry' AND class = 'lIrm08RYVk';
# 无法命中索引
SELECT * FROM student WHERE class = 'lIrm08RYVk';
```

再来看一个常见的面试题：如果有索引 `联合索引（a，b，c）`，查询 `a=1 AND c=1`会走索引么？`c=1` 呢？`b=1 AND c=1`呢？

先不要往下看答案，给自己 3 分钟时间想一想。

1. 查询 `a=1 AND c=1`：根据最左前缀匹配原则，查询可以使用索引的前缀部分。因此，该查询仅在 `a=1` 上使用索引，然后对结果进行 `c=1` 的过滤。
2. 查询 `c=1` ：由于查询中不包含最左列 `a`，根据最左前缀匹配原则，整个索引都无法被使用。
3. 查询`b=1 AND c=1`：和第二种一样的情况，整个索引都不会使用。

### 索引下推

​	**索引下推（Index Condition Pushdown, ICP）** 是 MySQL 5.6 引入的一个优化机制，用来提升查询效率。核心思想是，在扫描索引时，尽可能在存储引擎层**过滤**掉不满足查询条件的数据，减少回表次数，提高查询效率。对于复合条件查询，MySQL 会优先使用索引筛选能通过的行，然后再对符合条件的行进行回表操作。

**开启索引下推**：

```sql
SET optimizer_switch='index_condition_pushdown=on';
```

### 什么样的字段适合创建索引

**不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。

**被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。

**被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。

**频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。

**被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

### 索引为什么会失效

1. **查询条件中对索引列进行计算或函数操作**
   当你在查询语句中对索引列进行计算、函数操作或类型转换时，索引无法被有效利用。
   避免在索引列上使用函数或运算，尽量保持索引列原始的形式参与查询。

   ```sql
   -- 索引失效：
   SELECT * FROM users WHERE YEAR(create_time) = 2023;
   
   -- 索引有效：
   SELECT * FROM users WHERE create_time BETWEEN '2023-01-01' AND '2023-12-31';
   ```

2. **LIKE 模糊查询以 `%` 开头**
   当使用 `LIKE` 查询时，如果模式中以 `%` 开头，MySQL 无法使用索引。
   避免 `LIKE '%keyword%'`，而使用 `LIKE 'keyword%'`，使索引有效。

   ```sql
   -- 索引失效：
   SELECT * FROM users WHERE name LIKE '%John%';
   
   -- 索引有效：
   SELECT * FROM users WHERE name LIKE 'John%';
   ```

3. **复合索引未遵循最左前缀原则**
   在使用复合索引时，查询条件必须遵循最左前缀原则，否则索引失效。
   查询条件必须从复合索引的最左边开始，并且依次使用列，避免跳跃使用。

   ```sql
   -- 复合索引 (first_name, last_name)：
   
   -- 索引有效（遵循最左前缀）：
   SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe';
   
   -- 索引失效（跳过 first_name）：
   SELECT * FROM users WHERE last_name = 'Doe';
   ```

4. **使用 `OR` 查询**
   如果查询条件中使用 `OR`，且 `OR` 两侧的条件没有同时使用索引列，则索引会失效。
   将 `OR` 拆解为多个查询，用 `UNION` 合并结果。

5. **发生隐式转换**
   当查询条件和索引列的数据类型不一致时，MySQL 会进行隐式转换，导致索引失效。
   确保查询条件的值类型与索引列的类型一致。

   ```sql
   -- 假设 phone_number 是 VARCHAR 类型：
   
   -- 索引失效（整型与字符型不匹配）：
   SELECT * FROM users WHERE phone_number = 123456;
   
   -- 索引有效（字符类型一致）：
   SELECT * FROM users WHERE phone_number = '123456';
   ```

6. **过多的 NULL 值**
   如果一个列中的大部分数据是 `NULL`，即使在该列上建立了索引，也可能导致索引效率低下。
   避免在包含大量 `NULL` 值的列上建立索引，或者在设计表时设置合理的默认值。

7. **查询的数据量过大**
   即使使用了索引，当查询涉及的数据量过大时，MySQL 可能选择进行全表扫描，因为索引扫描成本高于全表扫描。
   优化 SQL 语句，限制查询结果集的大小，比如通过 `LIMIT` 限制数据量。

8. **更新频繁的字段**
   如果索引列经常更新，大量更新操作会导致索引频繁维护，影响索引的使用效果。
   避免在频繁更新的列上建立索引，或者减少不必要的索引列。

## 事务

### 什么是ACID

**原子性**（`Atomicity`）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

**一致性**（`Consistency`）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；

**隔离性**（`Isolation`）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

**持久性**（`Durability`）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 并发事务带来了哪些问题

1. 脏读
2. 丢失修改
3. 幻读
4. 不可重复读

### 并发事务的控制方法

并发事务的控制方法有几种，其中**锁机制**是最常用的。锁分为**共享锁（读锁）**和**排他锁（写锁）**，共享锁允许多个事务同时读取数据，但不允许修改；排他锁则阻止其他事务读取或修改。使用适当的锁可以避免并发事务带来的数据不一致问题。

另一种方法是**事务隔离级别**，通过设置不同的隔离级别（如读未提交、读已提交、可重复读和可串行化）来控制事务之间的干扰程度。低隔离级别性能较好但可能出现并发问题，高隔离级别则避免并发问题但性能较差。

**MVCC（多版本并发控制）**是另一种常用方法，尤其适用于数据库，如MySQL的InnoDB引擎。MVCC通过保存数据的多个版本，让读操作不阻塞写操作，从而提高了并发性能。

### sql隔离级别

mysql默认的隔离级别是**可重复读**

**读未提交（Read Uncommitted）**
在该级别下，一个事务可以读取另一个事务尚未提交的数据，这会导致“脏读”问题。

**读已提交（Read Committed）**
这是大多数数据库系统的默认隔离级别。在这个级别下，一个事务只能读取到已经提交的数据，避免了脏读。

**可重复读（Repeatable Read）**
该隔离级别确保在同一事务中多次读取同一行数据时，结果是相同的，解决了不可重复读问题，但仍可能出现幻读。

**可串行化（Serializable）**
这是最高的隔离级别，它通过强制事务串行化执行，防止所有并发问题，包括脏读、不可重复读和幻读。

## 锁

### 锁的种类

1. 行锁
2. 表锁
3. X锁
4. S锁
5. 意向锁

### 表级锁行级锁区别

1. 粒度
2. 死锁可能性
3. 锁冲突
4. 高并发下的性能

### 意向锁的作用

**意向锁** 的作用是为了 **提高表级别的并发控制效率**，它是表级锁的设计，用于标记事务打算在某些行上加锁。通过使用意向锁，InnoDB 能够在进行表级锁定操作时迅速判断是否允许锁定，避免在大表上对每一行的锁状态进行检查，从而提高性能。

1. **表级锁与行级锁的兼容性管理**：
   - 当事务想要加行级锁（共享锁或排他锁）时，它会先在表级别加意向锁，以表明事务准备在某些行上进行加锁操作。
   - 意向锁能与其他行级锁共存，减少锁冲突，同时允许更高的并发度。
2. **加速表级锁定判断**：
   - 如果一个事务需要对整个表加锁，InnoDB 只需检查表上的意向锁状态，而不需要逐行检查是否存在行级锁。
   - 这大幅提高了对大表加锁操作的效率。
3. **避免锁冲突**：
   - 通过意向锁，InnoDB 能够快速判断事务间的锁是否会冲突，从而避免发生不必要的锁等待。

#### 意向锁种类

- 意向排他锁 IX
- 意向共享锁 IS

### next-key-lock

​	**Next-Key Lock** 是 MySQL InnoDB 存储引擎中的一种锁机制，用来防止 **幻读** 现象的发生，尤其是在 **Repeatable Read（可重复读）** 隔离级别下。它结合了 **行锁（Record Lock）** 和 **间隙锁（Gap Lock）**，对一个数据范围加锁，确保事务操作的并发安全性。

- **Record Lock（记录锁）**：锁住精确的记录（行）本身，防止其他事务修改该记录。
- **Gap Lock（间隙锁）**：锁住两个记录之间的“间隙”，防止其他事务在该区间插入新的记录。

### 当前读和快照读

**快照读（Snapshot Read）**

- **定义**：读取已经提交的数据版本，而不是最新的数据。这是 MySQL 使用 **MVCC（多版本并发控制）** 提供的一种一致性读操作。
- 特点：
  - **读的是历史版本**：快照读不会锁住数据，它读取的是事务开始时的一个数据快照，而不是其他事务正在修改的数据。
  - **隔离级别**：常见于 **Repeatable Read（可重复读）** 和 **Read Committed（读已提交）** 隔离级别中。
  - **避免锁争用**：因为读取的不是当前数据版本，其他事务可以继续修改数据，不影响快照读的事务。适用于多读少写的场景。
- **示例**：`SELECT * FROM table WHERE ...;`（普通的 `SELECT` 语句在没有加锁的情况下就是快照读）

**当前读（Current Read）**

- **定义**：读取的是最新的数据版本，并且在读的时候锁住数据，确保读取的过程中数据不会被其他事务修改。
- 特点：
  - **读的是最新版本**：当前读会读取最新的数据，通常伴随着加锁操作，保证读取的数据是最新的、未被其他事务修改。
  - **锁定行**：当前读会对读取的行加锁，保证其他事务在该事务结束之前无法修改这些数据，防止并发修改。
  - **隔离级别**：常见于需要加锁的场景，如 **UPDATE**、**DELETE**、**SELECT ... FOR UPDATE** 等操作。
- 示例：
  - `SELECT ... FOR UPDATE;`（读取数据并加排他锁）
  - `SELECT ... LOCK IN SHARE MODE;`（读取数据并加共享锁）
  - `UPDATE table SET ... WHERE ...;`
  - `DELETE FROM table WHERE ...;`

### InnoDB存储引擎对MVCC的实现

​	`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改。

#### 隐藏字段

1. `DB_TRX_ID（6字节）`：表示最后一次插入或更新该行的事务 id。此外，`delete` 操作在内部被视为更新，只不过会在记录头 `Record header` 中的 `deleted_flag` 字段将其标记为已删除
2. `DB_ROLL_PTR（7字节）` 回滚指针，指向该行的 `undo log` 。如果该行未被更新，则为空
3. `DB_ROW_ID（6字节）`：如果没有设置主键且该表没有唯一非空索引时，`InnoDB` 会使用该 id 来生成聚簇索引

#### `Read View`

- `m_low_limit_id`：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见
- `m_up_limit_id`：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见
- `m_ids`：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务（正在内存中）
- `m_creator_trx_id`：创建该 `Read View` 的事务 ID

![trans_visible](https://javaguide.cn/assets/trans_visible-ekj9bMvL.png)

#### Undo Log

**插入 Undo Log**：

- 用于 **INSERT** 操作的回滚。
- 当发生插入操作时，Undo Log 记录的是插入的行信息，如果回滚则会删除这些行。
- 插入 Undo Log 仅在事务未提交前有用，事务一旦提交，插入 Undo Log 就会被丢弃，因为提交后不再需要回滚。

**修改 Undo Log**：

- 用于 **UPDATE** 和 **DELETE** 操作的回滚。
- 记录修改之前的数据，用于恢复数据到修改前的状态。如果事务需要回滚，可以通过 Undo Log 恢复修改前的数据。
- 修改 Undo Log 还用于 **MVCC** 快照读，通过 Undo Log 的内容为事务提供历史版本的数据。

#### RC和RR状态下MVCC的差异

**RC：**读已修改

**RR：**可重复读

在 RC 隔离级别下的 **`每次select`** 查询前都生成一个`Read View` (m_ids 列表)

在 RR 隔离级别下只在事务开始后 **`第一次select`** 数据前生成一个`Read View`（m_ids 列表）

#### MVCC + next-key-lock 防止幻读

`InnoDB`存储引擎在 RR 级别下通过 `MVCC`和 `Next-key Lock` 来解决幻读问题：

**1、执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据**

在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”

**2、执行 select...for update/lock in share mode、insert、update、delete 等当前读**

在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 [Next-key Lock](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks) 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。

## Mysql三大日志