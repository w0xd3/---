# `Mysql`笔记

https://javaguide.cn/database/mysql/

## 存储引擎

**事务支持**

- **MyISAM**：不支持事务，也没有回滚功能。一旦执行操作无法撤销。
- **InnoDB**：支持事务（ACID特性），可以使用 `COMMIT` 和 `ROLLBACK`，在出现错误时可以回滚事务，保证数据一致性。

**锁机制**

- **MyISAM**：使用表级锁，执行查询或写入操作时会锁定整个表，导致并发性能较差。
- **InnoDB**：使用行级锁，允许高并发读写操作，写入操作仅锁定特定行，因此并发性能更好。

**外键支持**

- **MyISAM**：不支持外键约束，因此无法直接在表间建立关系。
- **InnoDB**：支持外键，可以实现表之间的数据完整性和约束。

**数据恢复**

- **MyISAM**：在系统崩溃后，可能会造成数据丢失或损坏，恢复较困难。只支持简单的修复工具 `REPAIR TABLE`。
- **InnoDB**：崩溃恢复机制更完善，支持崩溃恢复（通过重做日志和回滚日志），可以最大程度上减少数据丢失。

**存储结构**

- **MyISAM**：使用表级存储结构，数据和索引分别存储在不同的文件中。表比较大时，性能可能下降。
- **InnoDB**：使用聚簇索引存储，数据与索引一起存储在同一个文件中，索引和数据一起优化存取效率。

## 存储数据结构

### B树



### B+树



### B/B+树区别





## 索引

### `Mysql `EXPLAIN 详解

各个字段的含义如下：

| **列名**      | **含义**                                     |
| ------------- | -------------------------------------------- |
| id            | SELECT 查询的序列标识符                      |
| select_type   | SELECT 关键字对应的查询类型                  |
| table         | 用到的表名                                   |
| partitions    | 匹配的分区，对于未分区的表，值为 NULL        |
| **type**      | 表的访问方法                                 |
| possible_keys | 可能用到的索引                               |
| **key**       | 实际用到的索引                               |
| key_len       | 所选索引的长度                               |
| ref           | 当使用索引等值查询时，与索引作比较的列或常量 |
| **rows**      | 预计要读取的行数                             |
| filtered      | 按表条件过滤后，留存的记录数的百分比         |
| **Extra**     | 附加信息                                     |

#### **type**

- type列表示连接类型，是性能优化的关键字段之一，常见的连接类型按效率由高到低排列如下：
  - `system`: 表中只有一行（这是一个特殊的 `const` 类型），速度非常快。
  - `const`: 表示表只有一个匹配的行，通过索引或者主键查找，这种类型是性能最优的。
  - `eq_ref`: 对于联合查询，表示每次从表中读取一行，通常出现在多表连接中，基于主键或唯一索引的关联。
  - `ref`: 非唯一索引扫描，会返回匹配某个值的所有行。
  - `range`: 通过索引查找一个范围的行。
  - `index`: 扫描整个索引（比全表扫描稍好），不使用数据文件。
  - `ALL`: 全表扫描，效率最低。

#### **extra**

- extra列显示关于查询的额外信息，常见的值有：
  - `Using where`: `MySQL` 会使用 `WHERE` 子句来过滤行。
  - `Using index`: 表示只使用索引进行查找，无需额外读取数据文件，性能较高。
  - `Using temporary`: `MySQL` 需要使用临时表来存储中间结果，通常发生在 `GROUP BY`、`ORDER BY` 操作中，可能需要优化。
  - `Using filesort`: `MySQL` 使用文件排序，通常出现在 `ORDER BY` 子句，表示没有使用索引进行排序，可能影响性能。
  - `Using join buffer`: 使用了连接缓冲区，意味着连接条件可能不够优化。

#### 案例

假设有一个查询语句：

```sql
EXPLAIN SELECT * FROM employees WHERE dept_no = 'd001';
```

返回结果类似：

| id   | select_type | table     | type | possible_keys | key     | key_len | ref   | rows | filtered | extra       |
| ---- | ----------- | --------- | ---- | ------------- | ------- | ------- | ----- | ---- | -------- | ----------- |
| 1    | SIMPLE      | employees | ref  | dept_no       | dept_no | 4       | const | 100  | 100      | Using where |

### 索引的类型

1. 按数据结构
   - **B-Tree 索引**：适用于等值和范围查询，使用最广泛。
   - **哈希索引**：只支持等值查询，速度快，不支持范围查询。
   - **R-Tree 索引**：用于多维空间数据查询，适合地理信息。
   - **位图索引**：适合重复值多的字段，效率高。
2. 按底层存储
   - **聚簇索引**：数据和索引存储在一起，查询效率高，但插入慢。
   - **非聚簇索引**：索引存储指针，支持多索引，但查询时可能回表。
3. 按应用维度
   - **主键索引**：唯一且不允许为空，自动生成聚簇索引。
   - **唯一索引**：保证列唯一性，提升查询速度。
   - **普通索引**：提升查询性能，无唯一性要求。
   - **全文索引**：加速大文本字段的内容搜索。
   - **组合索引**：多个字段联合索引，遵循最左前缀。
   - **覆盖索引**：查询所需字段都在索引中，无需回表。

### 聚簇索引和非聚簇索引的优缺点、区别

#### **聚簇索引 (Clustered Index)**

**概念：**

- 在聚簇索引中，表中的数据行按照索引列的顺序进行物理存储。
- 每个表只能有一个聚簇索引，因为数据行的物理顺序只能有一种。
- 在 MySQL 的 InnoDB 引擎中，主键默认是聚簇索引，如果没有指定主键，MySQL 会选择一个唯一的非空列作为聚簇索引。

#### 优点：

- **查询效率高**：当查询涉及聚簇索引列时，由于数据和索引在同一结构中，查询时不需要再次查找数据，查询速度更快，尤其是在范围查询时（例如 `BETWEEN`）。
- **顺序访问快**：聚簇索引将数据按索引列的顺序存储，适合顺序读取或范围查询。

#### 缺点：

- **插入和更新效率低**：由于数据需要按索引列排序存储，插入新的数据或更新现有数据可能需要对其他数据进行重排，导致效率下降。
- **占用更多空间**：当聚簇索引的列比较大时，重新排序和维护索引开销较高。
- **数据移动**：如果插入的数据不能按顺序放入现有位置，可能需要将数据移动到其他位置，这会导致更多的 IO 操作。

#### 场景：

- 适用于多范围查询、顺序查询以及查询返回多行的场景，例如时间戳、范围查询。

#### 非聚簇索引 (Non-clustered Index)

**概念：**

- 非聚簇索引中的索引顺序与表中数据的物理存储顺序没有关系。
- 在非聚簇索引中，索引结构包含指向数据行的指针（通常是指向聚簇索引或直接指向数据），不会改变数据的物理存储顺序。
- 一张表可以有多个非聚簇索引。

#### 优点：

- **插入和更新操作快**：数据物理存储顺序与索引顺序无关，插入新数据时不需要对整个表进行重排，只需要更新索引即可，减少了数据移动的开销。
- **多重索引**：非聚簇索引支持在同一个表中创建多个索引，可以在不同列上建立索引，优化特定列的查询性能。

#### 缺点：

- **查询效率较低**：当查询时，先需要通过索引查找到数据位置，然后再通过位置找到实际数据（称为“回表”操作）。特别是在范围查询时，由于指针跳转，效率不如聚簇索引。
- **占用更多空间**：非聚簇索引需要额外的空间存储指向数据行的指针，所以每个非聚簇索引都会增加额外的存储成本。

#### 场景：

- 适用于精确查询，特别是在查询特定列的场景下，如通过唯一标识符查找记录。

------

**区别总结：**

| 对比维度     | 聚簇索引                                   | 非聚簇索引                               |
| ------------ | ------------------------------------------ | ---------------------------------------- |
| **数据存储** | 数据和索引一起存储                         | 索引和数据分开存储                       |
| **查询速度** | 查询范围数据时速度快                       | 查询速度相对较慢，需要“回表”操作         |
| **插入速度** | 插入或更新数据时速度较慢，可能需要重排数据 | 插入或更新速度较快                       |
| **索引数量** | 每个表只能有一个聚簇索引                   | 每个表可以有多个非聚簇索引               |
| **适用场景** | 顺序查询、大数据集的范围查询               | 精确查找特定列，特别是在联合查询中效果好 |

### 最左前缀匹配原则

最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。

```sql
# 可以命中索引
SELECT * FROM student WHERE name = 'Anne Henry';
EXPLAIN SELECT * FROM student WHERE name = 'Anne Henry' AND class = 'lIrm08RYVk';
# 无法命中索引
SELECT * FROM student WHERE class = 'lIrm08RYVk';
```

再来看一个常见的面试题：如果有索引 `联合索引（a，b，c）`，查询 `a=1 AND c=1`会走索引么？`c=1` 呢？`b=1 AND c=1`呢？

先不要往下看答案，给自己 3 分钟时间想一想。

1. 查询 `a=1 AND c=1`：根据最左前缀匹配原则，查询可以使用索引的前缀部分。因此，该查询仅在 `a=1` 上使用索引，然后对结果进行 `c=1` 的过滤。
2. 查询 `c=1` ：由于查询中不包含最左列 `a`，根据最左前缀匹配原则，整个索引都无法被使用。
3. 查询`b=1 AND c=1`：和第二种一样的情况，整个索引都不会使用。

### 索引下推

​	**索引下推（Index Condition Pushdown, ICP）** 是 MySQL 5.6 引入的一个优化机制，用来提升查询效率。核心思想是，在扫描索引时，尽可能在存储引擎层过滤掉不满足查询条件的数据，减少回表次数，提高查询效率。对于复合条件查询，MySQL 会优先使用索引筛选能通过的行，然后再对符合条件的行进行回表操作。

**开启索引下推**：

```sql
SET optimizer_switch='index_condition_pushdown=on';
```

### 什么样的字段适合创建索引

**不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。

**被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。

**被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。

**频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。

**被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

### 索引为什么会失效

1. **查询条件中对索引列进行计算或函数操作**
   当你在查询语句中对索引列进行计算、函数操作或类型转换时，索引无法被有效利用。
   避免在索引列上使用函数或运算，尽量保持索引列原始的形式参与查询。

   ```sql
   -- 索引失效：
   SELECT * FROM users WHERE YEAR(create_time) = 2023;
   
   -- 索引有效：
   SELECT * FROM users WHERE create_time BETWEEN '2023-01-01' AND '2023-12-31';
   ```

2. **使用不等号 (`!=`, `<`, `>`, `<>`) 查询**
   在不等号查询中，虽然索引可以被部分利用，但后续的索引列将失效。
   如果可以，用 `BETWEEN` 或 `IN` 替代不等号查询，避免索引失效。

3. **LIKE 模糊查询以 `%` 开头**
   当使用 `LIKE` 查询时，如果模式中以 `%` 开头，MySQL 无法使用索引。
   避免 `LIKE '%keyword%'`，而使用 `LIKE 'keyword%'`，使索引有效。

   ```sql
   -- 索引失效：
   SELECT * FROM users WHERE name LIKE '%John%';
   
   -- 索引有效：
   SELECT * FROM users WHERE name LIKE 'John%';
   ```

4. **复合索引未遵循最左前缀原则**
   在使用复合索引时，查询条件必须遵循最左前缀原则，否则索引失效。
   查询条件必须从复合索引的最左边开始，并且依次使用列，避免跳跃使用。

   ```sql
   -- 复合索引 (first_name, last_name)：
   
   -- 索引有效（遵循最左前缀）：
   SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe';
   
   -- 索引失效（跳过 first_name）：
   SELECT * FROM users WHERE last_name = 'Doe';
   ```

5. **使用 `OR` 查询**
   如果查询条件中使用 `OR`，且 `OR` 两侧的条件没有同时使用索引列，则索引会失效。
   将 `OR` 拆解为多个查询，用 `UNION` 合并结果。

6. **数据类型不匹配**
   当查询条件和索引列的数据类型不一致时，MySQL 会进行隐式转换，导致索引失效。
   确保查询条件的值类型与索引列的类型一致。

   ```sql
   -- 假设 phone_number 是 VARCHAR 类型：
   
   -- 索引失效（整型与字符型不匹配）：
   SELECT * FROM users WHERE phone_number = 123456;
   
   -- 索引有效（字符类型一致）：
   SELECT * FROM users WHERE phone_number = '123456';
   ```

7. **过多的 NULL 值**
   如果一个列中的大部分数据是 `NULL`，即使在该列上建立了索引，也可能导致索引效率低下。
   避免在包含大量 `NULL` 值的列上建立索引，或者在设计表时设置合理的默认值。

8. **查询的数据量过大**
   即使使用了索引，当查询涉及的数据量过大时，MySQL 可能选择进行全表扫描，因为索引扫描成本高于全表扫描。
   优化 SQL 语句，限制查询结果集的大小，比如通过 `LIMIT` 限制数据量。

9. **更新频繁的字段**
   如果索引列经常更新，大量更新操作会导致索引频繁维护，影响索引的使用效果。
   避免在频繁更新的列上建立索引，或者减少不必要的索引列。

## 事务

### 并发事务带来了哪些问题

1. 脏读
2. 丢失修改
3. 幻读
4. 不可重复读

### 并发事务的控制方法

并发事务的控制方法有几种，其中**锁机制**是最常用的。锁分为**共享锁（读锁）**和**排他锁（写锁）**，共享锁允许多个事务同时读取数据，但不允许修改；排他锁则阻止其他事务读取或修改。使用适当的锁可以避免并发事务带来的数据不一致问题。

另一种方法是**事务隔离级别**，通过设置不同的隔离级别（如读未提交、读已提交、可重复读和可串行化）来控制事务之间的干扰程度。低隔离级别性能较好但可能出现并发问题，高隔离级别则避免并发问题但性能较差。

还有**乐观锁**和**悲观锁**的使用。乐观锁假设数据竞争很少，因此不加锁，而是通过检查版本号或时间戳在提交时验证数据是否被修改。悲观锁假设数据竞争频繁，会在操作前直接锁定资源以防止冲突。

**MVCC（多版本并发控制）**是另一种常用方法，尤其适用于数据库，如MySQL的InnoDB引擎。MVCC通过保存数据的多个版本，让读操作不阻塞写操作，从而提高了并发性能。

### sql隔离级别

mysql默认的隔离级别是**可重复读**

**读未提交（Read Uncommitted）**
在该级别下，一个事务可以读取另一个事务尚未提交的数据，这会导致“脏读”问题。

**读已提交（Read Committed）**
这是大多数数据库系统的默认隔离级别。在这个级别下，一个事务只能读取到已经提交的数据，避免了脏读。

**可重复读（Repeatable Read）**
该隔离级别确保在同一事务中多次读取同一行数据时，结果是相同的，解决了不可重复读问题，但仍可能出现幻读。

**可串行化（Serializable）**
这是最高的隔离级别，它通过强制事务串行化执行，防止所有并发问题，包括脏读、不可重复读和幻读。

## 锁

### 锁的种类

1. 行锁
2. 表锁
3. X锁
4. S锁
5. 意向锁

### 表级锁行级锁区别

1. 粒度
2. 死锁可能性
3. 锁冲突
4. 高并发下的性能

### 意向锁的作用

**意向锁** 的作用是为了 **提高表级别的并发控制效率**，它是表级锁的设计，用于标记事务打算在某些行上加锁。通过使用意向锁，InnoDB 能够在进行表级锁定操作时迅速判断是否允许锁定，避免在大表上对每一行的锁状态进行检查，从而提高性能。

1. **表级锁与行级锁的兼容性管理**：
   - 当事务想要加行级锁（共享锁或排他锁）时，它会先在表级别加意向锁，以表明事务准备在某些行上进行加锁操作。
   - 意向锁能与其他行级锁共存，减少锁冲突，同时允许更高的并发度。
2. **加速表级锁定判断**：
   - 如果一个事务需要对整个表加锁，InnoDB 只需检查表上的意向锁状态，而不需要逐行检查是否存在行级锁。
   - 这大幅提高了对大表加锁操作的效率。
3. **避免锁冲突**：
   - 通过意向锁，InnoDB 能够快速判断事务间的锁是否会冲突，从而避免发生不必要的锁等待。

#### 意向锁种类

- 意向排他锁 IX
- 意向共享锁 IS

### next-key-lock

​	**Next-Key Lock** 是 MySQL InnoDB 存储引擎中的一种锁机制，用来防止 **幻读** 现象的发生，尤其是在 **Repeatable Read（可重复读）** 隔离级别下。它结合了 **行锁（Record Lock）** 和 **间隙锁（Gap Lock）**，对一个数据范围加锁，确保事务操作的并发安全性。

- **Record Lock（记录锁）**：锁住精确的记录（行）本身，防止其他事务修改该记录。
- **Gap Lock（间隙锁）**：锁住两个记录之间的“间隙”，防止其他事务在该区间插入新的记录。

### 当前读和快照读

**快照读（Snapshot Read）**

- **定义**：读取已经提交的数据版本，而不是最新的数据。这是 MySQL 使用 **MVCC（多版本并发控制）** 提供的一种一致性读操作。
- 特点：
  - **读的是历史版本**：快照读不会锁住数据，它读取的是事务开始时的一个数据快照，而不是其他事务正在修改的数据。
  - **隔离级别**：常见于 **Repeatable Read（可重复读）** 和 **Read Committed（读已提交）** 隔离级别中。
  - **避免锁争用**：因为读取的不是当前数据版本，其他事务可以继续修改数据，不影响快照读的事务。适用于多读少写的场景。
- **示例**：`SELECT * FROM table WHERE ...;`（普通的 `SELECT` 语句在没有加锁的情况下就是快照读）

**当前读（Current Read）**

- **定义**：读取的是最新的数据版本，并且在读的时候锁住数据，确保读取的过程中数据不会被其他事务修改。
- 特点：
  - **读的是最新版本**：当前读会读取最新的数据，通常伴随着加锁操作，保证读取的数据是最新的、未被其他事务修改。
  - **锁定行**：当前读会对读取的行加锁，保证其他事务在该事务结束之前无法修改这些数据，防止并发修改。
  - **隔离级别**：常见于需要加锁的场景，如 **UPDATE**、**DELETE**、**SELECT ... FOR UPDATE** 等操作。
- 示例：
  - `SELECT ... FOR UPDATE;`（读取数据并加排他锁）
  - `SELECT ... LOCK IN SHARE MODE;`（读取数据并加共享锁）
  - `UPDATE table SET ... WHERE ...;`
  - `DELETE FROM table WHERE ...;`

### InnoDB存储引擎对MVCC的实现

​	`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改。

#### 隐藏字段

1. `DB_TRX_ID（6字节）`：表示最后一次插入或更新该行的事务 id。此外，`delete` 操作在内部被视为更新，只不过会在记录头 `Record header` 中的 `deleted_flag` 字段将其标记为已删除
2. `DB_ROLL_PTR（7字节）` 回滚指针，指向该行的 `undo log` 。如果该行未被更新，则为空
3. `DB_ROW_ID（6字节）`：如果没有设置主键且该表没有唯一非空索引时，`InnoDB` 会使用该 id 来生成聚簇索引

#### `Read View`

- `m_low_limit_id`：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见
- `m_up_limit_id`：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见
- `m_ids`：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务（正在内存中）
- `m_creator_trx_id`：创建该 `Read View` 的事务 ID

![trans_visible](https://javaguide.cn/assets/trans_visible-ekj9bMvL.png)

#### Undo Log

**插入 Undo Log**：

- 用于 **INSERT** 操作的回滚。
- 当发生插入操作时，Undo Log 记录的是插入的行信息，如果回滚则会删除这些行。
- 插入 Undo Log 仅在事务未提交前有用，事务一旦提交，插入 Undo Log 就会被丢弃，因为提交后不再需要回滚。

**修改 Undo Log**：

- 用于 **UPDATE** 和 **DELETE** 操作的回滚。
- 记录修改之前的数据，用于恢复数据到修改前的状态。如果事务需要回滚，可以通过 Undo Log 恢复修改前的数据。
- 修改 Undo Log 还用于 **MVCC** 快照读，通过 Undo Log 的内容为事务提供历史版本的数据。

#### RC和RR状态下MVCC的差异

**RC：**读已修改

**RR：**可重复读

在 RC 隔离级别下的 **`每次select`** 查询前都生成一个`Read View` (m_ids 列表)

在 RR 隔离级别下只在事务开始后 **`第一次select`** 数据前生成一个`Read View`（m_ids 列表）

## Mysql三大日志
