### 自我介绍引导

1. 个人情况
2. 实习经历（时间、职责、工作内容）
   1. 拓竹
      - 50%功能测试，30%接口测试，20%压力测试。还有做一些性能测试的工作。
   2. 村民贷，校企合作项目
      - 开发新需求；对旧接口进行调整；nacos热配置
3. 技能和专长
   1. java，对JVM和JUC有一定了解
   2. 自动化测试框架（pytest、selenium）、压力测试工具（jmeter）、接口测试工具（insomnia、postman）
   3. linux指令
   4. mysql的存储引擎、索引、锁
   5. 对spring有一点了解
4. 项目
   1. taskzen
      - 时间管理系统
        - 登录注册
        - todolist
        - 任务时间表
        - 时间洞察
        - AIGC报告

### 死锁

多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。

![image-20241018225901458](C:\Users\Wancy\AppData\Roaming\Typora\typora-user-images\image-20241018225901458.png)

#### 解决死锁的方法

解决死锁的方法可以从多个角度去分析，一般的情况下，有**预防，避免，检测和解除四种**。

- **预防** 是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
  1. 静态分配策略
  2. 层次分配策略（破坏循环等待链）
- **避免**则是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**
  - 银行家算法（分配前判断安不安全）
- **检测**是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除** 是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**。
  1. 立即结束所有进程
  2. 撤销涉及死锁的进程
  3. 抢占资源

### TCP和UDP的区别

1. 连接方式
2. 可靠性
3. 速度
4. TCP有流量控制和拥塞控制
5. 应用场景

![image-20241019092613887](C:\Users\Wancy\AppData\Roaming\Typora\typora-user-images\image-20241019092613887.png)

### DNS

#### 层级结构

自顶向下：

1. 根DNS服务器
2. 顶级域DNS服务器（TLD Top-Level-Domain）
3. 权威DNS服务器
4. 本地DNS服务器

#### 工作流程

- 递归
- 迭代

![img](https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process.png)

### Mysql

#### InnoDb和MyISAM区别

1. 事务
2. 锁
3. 外键
4. 数据存储和检索
5. 崩溃恢复

#### 索引类别

1. 按数据结构
   - **B-Tree 索引**：适用于等值和范围查询，使用最广泛。
   - **哈希索引**：只支持等值查询，速度快，不支持范围查询。
   - **R-Tree 索引**：用于多维空间数据查询，适合地理信息。
   - **位图索引**：适合重复值多的字段，效率高。
2. 按底层存储
   - **聚簇索引**：数据和索引存储在一起，查询效率高，但插入慢。
   - **非聚簇索引**：索引存储指针，支持多索引，但查询时可能回表。
3. 按应用维度
   - **主键索引**：唯一且不允许为空，自动生成聚簇索引。
   - **唯一索引**：保证列唯一性，提升查询速度。
   - **普通索引**：提升查询性能，无唯一性要求。
   - **全文索引**：加速大文本字段的内容搜索。
   - **组合索引**：多个字段联合索引，遵循最左前缀。
   - **覆盖索引**：查询所需字段都在索引中，无需回表。

#### 什么时候适合用索引

1. 列中属性不为null
2. 频繁查询字段
3. 条件查询字段
4. 排序字段
5. 连接字段

#### 索引失效

1. 使用组合索引，但查询条件未遵守最左匹配原则
2. 在索引列上进行计算、函数、类型转换等操作
3. 以%开头的Like查询
4. 查询条件中使用OR，且OR的前后条件有一个列没有索引
5. IN的取值范围过大，走全表扫描

### cookie、session、token区别

#### 工作原理

cookie的工作原理是将用户信息保存到浏览器的域中，每次发起请求时都携带这些信息。缺点是不安全。

session的工作原理是在第一次登录鉴权时，服务器创建一个会话，存储用户的信息，然后将sessionId返回给客户端（浏览器），每次请求时携带sessionId。优点是安全；缺点是占用服务器资源，并且存在多台服务器时无法使用。

token比上述两种更为常用，量级小且安全，常见的实现是使用JWT。在登陆成功后服务器返回一个jwt token给客户端，客户端后续请求时将这个token放到请求头的Authorization中。

### 进程和线程

进程是操作系统资源分配的最小单位，线程是程序执行的最小单位。

#### 区别

1. 资源开销
2. 安全性
3. 通信方式

#### 应用场景

1. 线程
   - 频繁创建销毁
   - CPU密集型
2. 进程
   - 对安全和稳定要求高。比如，浏览器使用独立进程处理不同标签页，以隔离崩溃影响。

### 调度算法

![image-20241018231900955](C:\Users\Wancy\AppData\Roaming\Typora\typora-user-images\image-20241018231900955.png)

### B树和B+树区别

- B+树非叶子节点不存储数据，相当于索引。叶子节点才存储数据
- B+树同层节点链表

## 开放性问题

### 浏览器白屏

### 从客户端排查

#### 可能的原因

1. javascript
2. 资源加载失败
3. API（HTTP状态码）
4. 网络问题
5. 代理问题
6. 插件
7. 浏览器缓存

#### 解决方案

- 使用浏览器开发者工具中的 **Console（控制台）**、**Network（网络）** 和 **Elements（元素）** 标签来检查页面加载过程中是否有错误、资源加载失败或数据问题。
- 根据具体的错误信息，检查 JavaScript 错误、网络请求失败或样式加载问题等。
- 清除缓存、更新浏览器、禁用插件等也是解决白屏问题的有效方法。

### 从服务器排查

- 查看服务器日志，分析是否有错误或异常。
- 检查 API 请求和响应，确认数据是否正常返回。
- 验证数据库和第三方服务是否工作正常。
- 排查反向代理、缓存、会话等配置是否正确。

### Pytest和JUnit的区别

junit大多是开发拿来自测的

我觉得功能上没什么区别，测试框架的顶层设计都是差不多的。比如说pytest支持参数化和异常测试，junit也支持。

区别更多在于生态和语言本身

1. python在自动化测试方面的生态比java好。天然就能跟request和selenium集成，java如果要发请求一般是使用apache的httpclient这个包。
2. python是脚本语言，也就是说在执行pytest指令时可以动态指定很多东西（比如说仅执行包含某个标签的用例）。而且python更倾向于使用函数，java更多是用类的设计。java代码冗余过多，作为测试人员我在乎的是用最少的代码解决问题，不关心细节。

我个人比较喜欢pytest的夹具和参数化测试这两个功能。

### 什么时候适合自动化

#### 自动化的应用场景

1. 稳定性高的场景
2. 回归测试时
3. 压力测试与负载测试
4. 数据驱动测试

#### 手动测试应用场景

1. 探索性测试
2. 用户体验
3. 快速迭代
4. 难以自动化（音频、视频、图像）

### Spring

待办：

个人项目补充一点内容

快速浏览spring的ioc、aop、事务

看计网

### 村民贷

#### redis缓存

1. 贷款客户数据缓存
2. 高风险客户预警信息缓存

#### mysql索引案例

见python文件

**输出：**

```
不使用索引的查询时间: 0.0753 秒
使用单列索引的查询时间: 0.0478 秒
使用覆盖索引的查询时间: 0.0214 秒
```

覆盖索引完胜，不用回表优势很大

### 个人项目亮点

#### 数据分析功能

#### `JWT` + 请求拦截 + 跨域问题

**`JWT`**

`JWT `是一个字符串，包含三部分：

1. **Header**（头部）
2. **Payload**（负载）
3. **Signature**（签名）

**请求拦截**

利用spring提供的`HandlerInterceptor`，配置拦截路径，指定拦截逻辑

**跨域**

1. 前端配置代理
2. 后端允许端口访问（`WebMvcConfigurer `）
