> 2024-10-20 我会直面失败

# 进度

[面试经典 150 题 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/studyplan/top-interview-150/)

**进度：**3/150

### 刷题知识点

- 倒序双指针 LeetCode88
- 双指针 LeetCode27
- 

# 二分



# 排序

稳定：插冒归，桶计基 -> 插帽龟，统计鸡

`nlogn`：快归堆 + 希尔

![img](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

**代码路径：**code -> sort

## 冒泡排序

​	冒泡排序（Bubble Sort）是一种**简单的排序算法**，它通过**反复交换相邻的元素**，使得较大的元素逐步“冒泡”到数组的末尾，较小的元素向数组的前面移动。该算法通过多次遍历数组，每次将未排序部分中的最大值移到最后，直到整个数组有序。

#### 算法步骤

1. **比较相邻的元素**：
   - 从数组的左边开始，依次比较相邻的两个元素。如果左边的元素大于右边的元素，就交换它们的位置。
2. **重复第一步**：
   - 对每一对相邻的元素执行比较和交换操作，直到数组末尾为止。
   - 通过一轮比较，最大的元素会“冒泡”到数组的最后。
3. **减少排序范围**：
   - 每次冒泡完成后，最大的元素已经在正确的位置，所以下一次遍历时，不需要再包括最后一个元素。
4. **重复上述步骤**：
   - 对剩余未排序的部分重复执行上述步骤，直到整个数组排序完成。

#### 时间复杂度

- 最佳情况：O(n) （数组已排序）
- 最差情况：O(n²) （数组逆序）
- 平均情况：O(n²)

## 选择排序

​	选择排序（Selection Sort）是一种**简单直观的排序算法**。它的基本思想是：每一轮从未排序的部分中**选出最小（或最大）元素**，将其与当前未排序部分的第一个元素交换，逐轮缩小未排序部分的范围，直到整个数组有序。

#### 执行步骤

**从未排序部分中选择最小元素**：

- 遍历整个数组，从未排序部分中找到最小的元素。

**将最小元素与未排序部分的第一个元素交换**：

- 找到最小值后，将其与未排序部分的第一个元素进行交换。

**缩小未排序范围**：

- 每次处理后，将未排序部分缩小一位，继续从剩余部分中寻找最小值。

**重复上述步骤**：

- 直到未排序部分只剩下一个元素，排序完成。

#### 时间复杂度

- 最佳情况：O(n²)
- 最差情况：O(n²)
- 平均情况：O(n²)

#### 思考：选择排序为什么是不稳定的

1. **初始数组**：`[1, 3, 3, 2]`
2. **第一轮**：找到剩余未排序部分 `[3, 3, 2]` 的最小值 `1`，它已经在第一个位置，因此不需要交换。结果还是 `[1, 3, 3, 2]`。
3. **第二轮**：找到剩余未排序部分 `[3, 3, 2]` 中的最小值 `2`，将它与第二个位置的 `3` 交换。结果是 `[1, 2, 3, 3]`。

现在，**相同的两个 `3` 发生了相对顺序的改变**：原本第一个 `3` 在第二个位置，现在它到了第三个位置，原本第三个位置的 `3` 变成了第四个位置。这破坏了相同元素的相对顺序，因此选择排序是不稳定的。

## 插入排序

​	插入排序（Insertion Sort）是一种**简单直观的排序算法**。它的基本思想是：将数组分为**已排序部分**和**未排序部分**。每次从未排序部分取出一个元素，**将其插入到已排序部分的正确位置**，使已排序部分始终保持有序。重复此过程，直到所有元素都被插入为止。

#### 执行步骤

1. **从第一个元素开始**
   - 第一个元素视为已经排好序的部分。
2. **从未排序部分选择元素**
   - 从第二个元素开始，逐个取出每个元素，将其插入到前面的已排序部分，使前面的部分仍然保持有序。
3. **比较并插入**
   - 将未排序部分的第一个元素与已排序部分的元素从后往前比较，找到合适的位置插入。
4. **重复步骤**
   - 重复上述操作，直到所有元素都排好序。

#### 时间复杂度

- 最佳情况：O(n) （数组已排序）
- 最差情况：O(n²) （数组逆序）
- 平均情况：O(n²)

## 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

#### 执行步骤

1. **确定步长序列**：希尔排序首先将数组元素按照某个**步长**（gap）进行分组。例如，最开始可能使用较大的步长，将数组分为几个子序列。
2. **对每组进行插入排序**：在每个步长下，对每个子序列应用插入排序。由于步长较大，数据可以跨越较远的位置，快速调整到接近正确的位置。
3. **逐步缩小步长**：不断缩小步长（通常是原步长的一半），重复执行插入排序。随着步长减小，数据逐渐趋于有序。
4. **当步长为1时**：最后一次的插入排序与普通的直接插入排序相同，这时整个数组已经接近有序，因此最后的排序操作非常快。

#### 思考：为什么希尔排序比插入排序快

1. **减少比较和移动次数**：希尔排序通过大步长的移动使元素迅速接近正确位置，减少了插入排序中大量的比较和移动操作。在步长减小到 1 时，数组已经接近有序，因此最后的插入排序所需的操作非常少。
2. **跨组比较**：由于希尔排序每次跨组进行插入排序，可以将一些元素快速挪到更靠近最终位置的地方，这加速了排序过程。

**需要注意**，由于希尔排序依赖于步长序列，不同的**步长序列**会产生不同的时间复杂度，无法给出单一的时间复杂度公式，但其表现可以总结如下：

- **最差情况**：对于原始的希尔序列，最坏时间复杂度为 **O(n²)**，类似于插入排序。
- **改进步长的情况**：通过选择更优化的步长序列，最坏时间复杂度可以降到 **O(n^(4/3))** 到 **O(n log n)** 之间。
- **平均情况**：希尔排序的平均时间复杂度通常在 **O(n log n)** 和 **O(n^(3/2))** 之间，比插入排序的 **O(n²)** 要高效得多。

#### 思考：**为什么插入排序是稳定的，而希尔排序不是？**

希尔排序可以被视为多次分组的插入排序，而**插入排序是稳定的**，这是因为插入排序中只会对相邻元素进行比较和交换。如果两个元素相同，插入排序会保留它们的相对顺序。

然而，希尔排序由于分组后在**跨步长**的元素上进行比较和移动，可能会导致相同元素不再保持原来的相对顺序，因此希尔排序是**不稳定的**。

## 归并排序

​	归并排序（Merge Sort）是一种**分治法**（Divide and Conquer）的经典排序算法，它通过将数组不断地拆分成较小的子数组，分别对这些子数组进行排序，最后将它们合并成一个有序数组来实现排序。归并排序的关键是**分**与**合**两个步骤。

![img](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)

#### 执行步骤

**分割（Divide）：**

- 将数组递归地分成两半，直到每个子数组的长度为 1（此时的数组已经是有序的）。

**合并（Conquer）：**

- 将两个有序的子数组合并成一个有序数组，直到所有的子数组合并为一个完整的有序数组。

## 快速排序

​	快速排序（Quick Sort）是一种高效的排序算法，由于其良好的性能和简单的实现，成为最广泛使用的排序算法之一。它的基本思想是通过“分治法”将数组分为两个子数组，然后递归地对这两个子数组进行排序。以下是快速排序的详细介绍。

#### 执行步骤

1. **选择基准（Pivot）**：
   - 从待排序的数组中选择一个元素作为“基准”。基准的选择可以是数组的第一个元素、最后一个元素、随机选择的元素或中间元素等。
2. **分区（Partition）**：
   - 将数组重新排列，使得所有小于基准的元素放在基准的左侧，所有大于基准的元素放在基准的右侧。完成后，基准将处于其最终位置。
3. **递归排序**：
   - 对基准左侧和右侧的子数组分别递归执行快速排序。

## 堆排序

堆排序（Heap Sort）是一种基于**二叉堆**数据结构的**选择排序**算法。它首先构建一个最大堆（或最小堆），然后将堆顶元素（最大值或最小值）与最后一个元素交换，并将剩余的元素重新调整为堆结构，重复这一过程直到整个数组有序。

堆排序的核心是**堆的性质**，即在一个最大堆中，根节点的值总是大于等于子节点的值。通过不断调整堆结构和交换元素，堆排序可以实现排序。

#### 执行步骤

**构建最大堆**：

- 从数组的**非叶子节点**开始，将整个数组构建为一个最大堆。

**排序**：

- 每次将堆顶元素（最大值）与堆的最后一个元素交换，然后调整剩余的部分为最大堆，重复这个过程，直到数组有序。

## 计数排序

​	计数排序（Counting Sort）是一种非比较型的排序算法，主要用于对整数范围较小的数据进行排序。它通过计数每个元素出现的次数来确定每个元素的位置，因此在某些情况下能够实现线性时间复杂度的排序。以下是计数排序的详细介绍。

![img](https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif)

#### 执行步骤

1. **统计元素出现次数**：遍历待排序的数组，统计每个元素出现的次数，存储在一个计数数组中。
2. **计算位置**：根据计数数组，计算每个元素在输出数组中的最终位置。
3. **构建输出数组**：使用计数信息填充输出数组，最后将输出数组复制回原数组。